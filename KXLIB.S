;========================================================================================
;
; KXLIB version 0.14 by はう (Hau) ＆ みゆ (miyu rose)
;
;        KXLIB Designer    みゆ (miyu rose)
;              Programmer  X68KBBS：X68K0001
;                          Twitter：@arith_rose
;
;        Special Adviser   はう (Hau) さま
;        KXLIB Tester      X68KBBS：X68K0024
;                          Twitter：@Hau_oli
;
;        KeplerX Developer くにちこ (Kunihiko Ohnaka) さま
;                          X68KBBS：X68K0044
;                          Twitter：@kunichiko
;
;========================================================================================

    .include    doscall.mac
    .include    KeplerX.h

    .cpu    68000

;========================================================================================

    .text
    .even

;========================================================================================
;
    KX_detect_KeplerX::                         ; KeplerX の装着判定
;
;   return  d0.l                                ; エラーコード
;                                               ;   0: 装着されています
;                                               ;  -1: バスエラー
;                                               ;  -2: KeplerX 以外の何かに占有されてます
;
;----------------------------------------------------------------------------------------

    movem.l d1/a0-a1,-(sp)                      ; d1, a0, a1 を退避

    moveq.l #-1,d1                              ; バスエラー時のエラーコード

    move.l  sp,a0                               ; spを退避
    move.l  $0008.w,a1                          ; バスエラーのベクタを退避
    move.l  #1f,$0008.w                         ; バスエラーのベクタフック

    bsr     KX_get_ID                           ; ID 文字列を取得
    cmp.w   #'KX',d0                            ; 'KX' と比較して
    beq     @f                                  ;  同じなら検出成功

    moveq.l #-2,d1                              ; 見つかんなかったエラーコード
    bra     1f                                  ; おしまい
@@:
    moveq.l #0,d1                               ; 見つかったヽ(=´▽`=)ﾉ
1:
    move.l  a0,sp                               ; spを復元
    move.l  a1,$0008.w                          ; バスエラーのベクタを復元

    move.l  d1,d0                               ; エラーコード

    movem.l (sp)+,d1/a0-a1                      ; d1, a0, a1 を復元
    rts                                         ; おしまい

;========================================================================================
;
    KX_detect_X68030::                          ; X68030 シリーズ判定
;
;   return  d0.b                                ; $00: X68030
;                                               ; $ff: X68000
;
;----------------------------------------------------------------------------------------

    cmp.b   #$DC, $E8E00B                       ; X68030シリーズ
    beq     @f                                  ;  ならば次へ

    st.b    d0                                  ; シリーズは X68000
    rts
@@:
    clr.b   d0                                  ; シリーズは X68030
    rts

;========================================================================================
;
    KX_get_ID::                                 ; ID を取得します
;
;   return  d0.w                                ; $ECB000 REG0: ID
;
;----------------------------------------------------------------------------------------

    move.w  _KX_REG+_KX_ID,d0                   ; ID 文字列を取得
    rts                                         ; おしまい

;========================================================================================
;
    KX_get_Version::                            ; 基板のバージョンを取得します
;
;   return  d0.w                                ; $ECB002 REG1: Version
;
;----------------------------------------------------------------------------------------

    move.w _KX_REG+_KX_Version,d0               ; 基板のバージョンを取得
    rts                                         ; おしまい

;========================================================================================
;
    KX_get_VersionCode::                        ; 基板のバージョンコードを取得します
;
;   return  d0.w                                ; バージョンコード
;
;----------------------------------------------------------------------------------------

    move.w _KX_REG+_KX_Version,d0               ; 基板のバージョンを取得
    andi.w  #$00F0,d0                           ; バージョンコードをマスクして
    lsr.b   #4,d0                               ;  数値化

    rts                                         ; おしまい

;========================================================================================
;
    KX_get_VersionCodeName::                    ; 基板のバージョンコード名を取得します
;
;   return  a0.l                                ; バージョンコード名のアドレス
;
;----------------------------------------------------------------------------------------

    move.l  d0,-(sp)                            ; d0 を退避

    lea.l   KX_VersionCodeName,a0               ; バージョンコード名の先頭アドレス
    bsr     KX_get_VersionCode                  ; 基板のバージョンコードを取得
    cmp     #$0B,d0                             ; 11 と比較して
    ble     @f                                  ;  以下なら次へ
    move.b  #$0B,d0                             ; 強制的に 11 にする
@@:
    andi.l  #$000000FF,d0                       ; アドレスに加算するために32bit化して
    lsl.l   #3,d0                               ;  8倍する
    add.l   d0,a0                               ; バージョンコード名の先頭アドレス

    move.l  (sp)+,d0                            ; d0 を復元
    rts                                         ; おしまい

;========================================================================================
;
    KX_get_PatchVersion::                       ; 基板のパッチバージョンを取得します
;
;   return  d0.w                                ; パッチバージョン
;
;----------------------------------------------------------------------------------------

    move.w _KX_REG+_KX_Version,d0               ; 基板のバージョンを取得
    and.w   #$000F,d0                           ; パッチバージョンをマスクして数値化

    rts                                         ; おしまい

;========================================================================================
;
    KX_get_PatchVersionName::                   ; 基板のパッチバージョン名を取得します
;
;   return  a0.l                                ; パッチバージョン名のアドレス
;
;----------------------------------------------------------------------------------------

    move.l  d0,-(sp)                            ; d0 を退避

    lea.l   KX_PatchVersionName,a0              ; パッチバージョン名の先頭アドレス
    bsr     KX_get_PatchVersion                 ; パッチバージョンを取得
    bne     @f
    lea.l   KX_NULL,a0                          ; 空文字列の先頭アドレス
    bra     99f                                 ; おしまい
@@:
    andi.l  #$0F,d0                             ; アドレスに加算するために32bit化
    cmp.b   #$0A,d0                             ; 10 と比較して
    bhs     @f                                  ;  unsigned で大きければスキップ

    add.l   #$F3<<24+'0'<<16+$F3<<8+'0',d0      ; 十進文字列化(10未満)
    bra     @f                                  ; 次へ
@@:
    add.l   #$F3<<24+'1'<<16+$F3<<8+'0'-$0A,d0  ; 十進文字列化(10以上)
@@:
    move.l  d0,12(a0)                           ; 書き込む
99:
    move.l  (sp)+,d0                            ; d0 を復元
    rts                                         ; おしまい

;========================================================================================
;
    KX_get_ExpansionMemory::                    ; 増設メモリの有効無効を取得します
;
;   return  d0.w                                ; $ECB004 REG2: Expansion Memory Enable Flags
;
;----------------------------------------------------------------------------------------

    move.w  _KX_REG+_KX_ExpansionMemory,d0      ; 増設メモリの有効無効を取得
    rts                                         ; おしまい

;========================================================================================
;
    KX_set_ExpansionMemory::                    ; 増設メモリの有効無効を設定します
;
;   arg     d0.w                                ; $ECB004 REG2: Expansion Memory Enable Flags
;
;----------------------------------------------------------------------------------------

    move.w  d0,_KX_REG+_KX_ExpansionMemory      ; 増設メモリの有効無効を設定
    rts                                         ; おしまい

;========================================================================================
;
    KX_check_AutoMemoryDetection::              ; メモリ自動検出機能の有効無効を取得します
;
;   return  d0.b                                ; メモリ自動検出機能の有効無効
;                                               ;  $FF(有効)
;                                               ;  $00(無効)
;
;----------------------------------------------------------------------------------------

    btst.b  #0,_KX_REG+_KX_ExpansionMemory+1    ; メモリの自動検出機能の有効無効が
    beq     @f                                  ;  0 つまり無効なら次へ

    st.b    d0                                  ; 機能は有効
    rts                                         ; おしまい
@@:
    clr.b   d0                                  ; 機能は無効
    rts                                         ; おしまい

;========================================================================================
;
    KX_set_AutoMemoryDetection::                ; メモリ自動検出機能の有効無効を設定します
;
;   arg  d0.b                                   ; メモリ自動検出機能の有効無効
;                                               ;  $FF(有効)
;                                               ;  $00(無効)
;----------------------------------------------------------------------------------------

    tst.b   d0                                  ; 引数が
    beq     @f                                  ;  無効なら次へ

    bset.b  #0,_KX_REG+_KX_ExpansionMemory+1    ; メモリ自動検出機能の有効化
    rts                                         ; おしまい
@@:
    bclr.b  #0,_KX_REG+_KX_ExpansionMemory+1    ; メモリ自動検出機能の無効化
    rts                                         ; おしまい

;========================================================================================
;
    KX_enable_AutoMemoryDetection::             ; メモリ自動検出機能を有効にします
;
;----------------------------------------------------------------------------------------

    bset.b  #0,_KX_REG+_KX_ExpansionMemory+1    ; メモリ自動検出機能の有効化
    rts                                         ; おしまい

;========================================================================================
;
    KX_disable_AutoMemoryDetection::            ; メモリ自動検出機能を無効にします
;
;----------------------------------------------------------------------------------------

    bclr.b  #0,_KX_REG+_KX_ExpansionMemory+1    ; メモリ自動検出機能の無効化
    rts                                         ; おしまい

;========================================================================================
;
    KX_toggle_AutoMemoryDetection::             ; メモリ自動検出機能の有効無効をトグルします
;
;----------------------------------------------------------------------------------------

    bchg.b  #0,_KX_REG+_KX_ExpansionMemory+1    ; メモリ自動検出機能の有効無効をトグル
    rts                                         ; おしまい

;========================================================================================
;
    KX_get_ExpandedMemorySize::                 ; 増設されたメモリサイズ(MB)を取得します
;
;   return  d0.w                                ; 増設されたメモリサイズ(MB)
;
;----------------------------------------------------------------------------------------

    move.l  d1,-(sp)                            ; d1 を退避

    move.w  _KX_REG+_KX_ExpansionMemory,d0      ; 増設メモリの有効無効を取得
    bclr.l  #0,d0                               ; 増設メモリの有効無効のみマスク

    clr.w   d1                                  ; メモリサイズカウンタ(MB)
@@:
    btst.l  #11,d0                              ; bit11 が
    beq     @f                                  ;  0 なのでループを抜ける
    addq.b  #1,d1                               ; メモリサイズカウンタをインクリメント
    lsl.w   #1,d0                               ; 増設メモリの有効無効を1bit左シフト
    bra     @b                                  ; ループ
@@:
    move.w  d1,d0                               ; メモリサイズを取得

    move.l  (sp)+,d1                            ; d1 を復元
    rts                                         ; おしまい

;========================================================================================
;
    KX_get_Peripheral::                         ; Mercury, MIDI I/F Board, MemoryBoard の有効無効を取得します
;
;   return  d0.w                                ; $ECB006 REG3: Peripheral Enable Flags
;
;----------------------------------------------------------------------------------------

    move.w  _KX_REG+_KX_Peripheral,d0           ; Mercury, MIDI I/F Board, MemoryBoard の有効無効を取得
    rts                                         ; おしまい

;========================================================================================
;
    KX_set_Peripheral::                         ; Mercury, MIDI I/F Board, MemoryBoard の有効無効を設定します
;
;   arg  d0.w                                   ; $ECB006 REG3: Peripheral Enable Flags
;
;----------------------------------------------------------------------------------------

    move.w  d0,_KX_REG+_KX_Peripheral           ; Mercury, MIDI I/F Board, MemoryBoard の有効無効を設定
    rts                                         ; おしまい

;========================================================================================
;
    KX_check_MercuryUnit::                      ; Mercury Unit 機能の有効無効を取得します
;
;   return  d0.b                                ; Mercury Unit 機能の有効無効
;                                               ;  $FF(有効)
;                                               ;  $00(無効)
;
;----------------------------------------------------------------------------------------

    btst.b  #2,_KX_REG+_KX_Peripheral+1         ; Mercury Unit 機能の有効無効が
    beq     @f                                  ;  0 つまり無効なら次へ

    st.b    d0                                  ; 機能は有効
    rts                                         ; おしまい
@@:
    clr.b   d0                                  ; 機能は無効
    rts                                         ; おしまい

;========================================================================================
;
    KX_set_MercuryUnit::                        ; Mercury Unit 機能の有効無効を設定します
;
;   arg  d0.b                                   ; Mercury Unit 機能の有効無効
;                                               ;  $FF(有効)
;                                               ;  $00(無効)
;
;----------------------------------------------------------------------------------------

    tst.b   d0                                  ; 引数が
    beq     @f                                  ;  無効なら次へ

    bset.b  #0,_KX_REG+_KX_ExpansionMemory+1    ; Mercury Unit 機能の有効化
    rts                                         ; おしまい
@@:
    bclr.b  #0,_KX_REG+_KX_ExpansionMemory+1    ; Mercury Unit 機能の無効化
    rts                                         ; おしまい

;========================================================================================
;
    KX_enable_MercuryUnit::                     ; Mercury Unit 機能を有効にします
;
;----------------------------------------------------------------------------------------

    bset.b  #2,_KX_REG+_KX_Peripheral+1         ; Mercury Unit 機能の有効化
    rts                                         ; おしまい

;========================================================================================
;
    KX_disable_MercuryUnit::                    ; Mercury Unit 機能を無効にします
;
;----------------------------------------------------------------------------------------

    bclr.b  #2,_KX_REG+_KX_Peripheral+1         ; Mercury Unit 機能の無効化
    rts                                         ; おしまい

;========================================================================================
;
    KX_toggle_MercuryUnit::                     ; Mercury Unit 機能の有効無効をトグルします
;
;----------------------------------------------------------------------------------------

    bchg.b  #2,_KX_REG+_KX_Peripheral+1         ; Mercury Unit 機能の有効無効をトグル
    rts                                         ; おしまい

;----------------------------------------------------------------------------------------
;
    KX_check_MIDIIFBoard::                      ; MIDI I/F Board 機能の有効無効を取得します
;
;   return  d0.b                                ; MIDI I/F Board 機能の有効無効(下位1bit)
;                                               ;  $FF(有効)
;                                               ;  $00(無効)
;
;----------------------------------------------------------------------------------------

    btst.b  #1,_KX_REG+_KX_Peripheral+1         ; MIDI I/F Board 機能の有効無効が
    beq     @f                                  ;  0 つまり無効なら次へ

    st.b    d0                             ; MIDI I/F Board 機能は有効
    rts                                         ; おしまい
@@:
    clr.b   d0                                  ; MIDI I/F Board 機能は無効
    rts                                         ; おしまい

;========================================================================================
;
    KX_set_MIDIIFBoard::                        ; MIDI I/F Board 機能の有効無効を設定します
;
;   arg  d0.b                                   ; MIDI I/F Board 機能の有効無効
;                                               ;  $FF(有効)
;                                               ;  $00(無効)
;
;----------------------------------------------------------------------------------------

    tst.b   d0                                  ; 引数が
    beq     @f                                  ;  無効なら次へ

    bset.b  #0,_KX_REG+_KX_ExpansionMemory+1    ; MIDI I/F Board 機能の有効化
    rts                                         ; おしまい
@@:
    bclr.b  #0,_KX_REG+_KX_ExpansionMemory+1    ; MIDI I/F Board 機能の無効化
    rts                                         ; おしまい

;========================================================================================
;
    KX_enable_MIDIIFBoard::                     ; MIDI I/F Board 機能を有効にします
;
;----------------------------------------------------------------------------------------

    bset.b  #1,_KX_REG+_KX_Peripheral+1         ; MIDI I/F Board 機能の有効化
    rts                                         ; おしまい

;========================================================================================
;
    KX_disable_MIDIIFBoard::                    ; MIDI I/F Board 機能を無効にします
;
;----------------------------------------------------------------------------------------

    bclr.b  #1,_KX_REG+_KX_Peripheral+1         ; MIDI I/F Board 機能の無効化
    rts                                         ; おしまい

;========================================================================================
;
    KX_toggle_MIDIIFBoard::                     ; MIDI I/F Board 機能の有効無効をトグルします
;
;----------------------------------------------------------------------------------------

    bchg.b  #1,_KX_REG+_KX_Peripheral+1         ; MIDI I/F Board 機能の有効無効をトグル
    rts                                         ; おしまい

;----------------------------------------------------------------------------------------
;
    KX_check_MemoryBoard::                      ; Memory Board 機能の有効無効を取得します
;
;   return  d0.b                                ; Memory Board 機能の有効無効(下位1bit)
;                                               ;   1: 有効
;                                               ;   0: 無効
;
;----------------------------------------------------------------------------------------

    btst.b  #0,_KX_REG+_KX_Peripheral+1         ; Memory Board 機能の有効無効が
    beq     @f                                  ;  0 つまり無効なら次へ

    st.b    d0                                  ; Memory Board 機能は有効
    rts                                         ; おしまい
@@:
    clr.b   d0                                  ; Memory Board 機能は無効
    rts                                         ; おしまい

;========================================================================================
;
    KX_set_MemoryBoard::                        ; Memory Board 機能の有効無効を設定します
;
;   arg  d0.b                                   ; Memory Board 機能の有効無効
;                                               ;  $FF(有効)
;                                               ;  $00(無効)
;
;----------------------------------------------------------------------------------------

    tst.b   d0                                  ; 引数が
    beq     @f                                  ;  無効なら次へ

    bset.b  #0,_KX_REG+_KX_ExpansionMemory+1    ; Memory Board 機能の有効化
    rts                                         ; おしまい
@@:
    bclr.b  #0,_KX_REG+_KX_ExpansionMemory+1    ; Memory Board 機能の無効化
    rts                                         ; おしまい

;========================================================================================
;
    KX_enable_MemoryBoard::                     ; Memory Board 機能を有効にします
;
;----------------------------------------------------------------------------------------

    bset.b  #0,_KX_REG+_KX_Peripheral+1          ; Memory Board 機能の有効化
    rts                                         ; おしまい

;========================================================================================
;
    KX_disable_MemoryBoard::                    ; Memory Board 機能を無効にします
;
;----------------------------------------------------------------------------------------

    bclr.b  #0,_KX_REG+_KX_Peripheral+1         ; Memory Board 機能の無効化
    rts                                         ; おしまい

;========================================================================================
;
    KX_toggle_MemoryBoard::                     ; Memory Board 機能の有効無効をトグルします
;
;----------------------------------------------------------------------------------------

    bchg.b  #0,_KX_REG+_KX_Peripheral+1         ; Memory Board 機能の有効無効をトグル
    rts                                         ; おしまい

;========================================================================================
;
    KX_get_SoundVolume1::                       ; S/PDIF(光)入力、mt32-pi、YM2151、ADPCM の音量を取得します
;
;   return  d0.w                                ; $ECB008 REG4: Sound Volume Adjust 1
;
;----------------------------------------------------------------------------------------

    move.w  _KX_REG+_KX_SoundVolume1,d0         ; S/PDIF(光)入力、mt32-pi、YM2151、ADPCM の音量を取得
    rts                                         ; おしまい

;========================================================================================
;
    KX_set_SoundVolume1::                       ; S/PDIF(光)入力、mt32-pi、YM2151、ADPCM の音量を設定します
;
;   arg     d0.w                                ; $ECB008 REG4: Sound Volume Adjust 1
;
;----------------------------------------------------------------------------------------

    move.w  d0,_KX_REG+_KX_SoundVolume1         ; S/PDIF(光)入力、mt32-pi、YM2151、ADPCM の音量を設
    rts                                         ; おしまい

;========================================================================================
;
    KX_get_SPDIFVolume::                        ; S/PDIF(光)入力 の音量を取得します
;
;   return  d0.b                                ; S/PDIF(光)入力 の音量
;                                               ;  $F8:[0] 0% (-8) 〜 $07:[F] 187.5% (+7)
;
;----------------------------------------------------------------------------------------

    move.b  _KX_REG+_KX_SoundVolume1,d0         ; S/PDIF(光)入力、mt32-pi の音量を取得
    asr.b   #4,d0                               ; 音量を signed byte 化

    rts                                         ; おしまい

;========================================================================================
;
    KX_set_SPDIFVolume::                        ; S/PDIF(光)入力 の音量を設定します
;
;   arg     d0.b                                ; S/PDIF(光)入力 の指定音量
;                                               ;  (下位4bit $8:[0](-8) 〜 $7:[F](+7))
;   return  d0.b                                ; 実際に設定した音量
;                                               ;  ($F8:[0](-8) 〜 $07:[F](+7))
;
;----------------------------------------------------------------------------------------

    move.l  d1,-(sp)                            ; d1 を退避

    move.b  _KX_REG+_KX_SoundVolume1,d1         ; S/PDIF(光)入力、mt32-pi の音量を取得
    andi.b  #$0F,d1                             ; S/PDIF(光)入力の音量 bit をクリアして
    lsl.b   #4,d0                               ; 指定音量 4bit を適切に配置して
    or.b    d0,d1                               ;  差し込んで
    move.b  d1,_KX_REG+_KX_SoundVolume1         ;   書き込む
    asr.b   #4,d0                               ; 設定した音量を signed byte 化

    move.l  (sp)+,d1                            ; d1 を復元
    rts                                         ; おしまい

;========================================================================================
;
    KX_turn_SPDIFVolume::                       ; S/PDIF(光)入力 の音量を相対設定します
;
;   arg     d0.b                                ; 指定相対音量 $80:-128 〜 $7F:+127
;   return  d0.b                                ; 実際に設定した音量
;                                               ;  ($F8:[0](-8) 〜 $07:[F](+7))
;
;----------------------------------------------------------------------------------------

    move.l  d1,-(sp)                            ; d1 を退避

    move.b  d0,d1                               ; 指定相対音量を d1 に
    bsr     KX_get_SPDIFVolume                  ; 現在設定音量を d0 に
    bsr     KX_turn_Volume                      ; 設定する音量を取得
    bsr     KX_set_SPDIFVolume                  ; 音量を設定

    move.l  (sp)+,d1                            ; d1 を復元
    rts                                         ; おしまい

;========================================================================================
;
    KX_get_mt32piVolume::                       ; mt32-pi の音量を取得します
;
;   return  d0.b                                ; mt32-pi の音量
;                                               ;  $F8:[0] 0% (-8) 〜 $07:[F] 187.5% (+7)
;
;----------------------------------------------------------------------------------------

    move.b  _KX_REG+_KX_SoundVolume1,d0         ; S/PDIF(光)入力、mt32-pi の音量を取得
    lsl.b   #4,d0                               ; 音量を一旦最上位bitへ移動させてから
    asr.b   #4,d0                               ;  signed byte 化

    rts                                         ; おしまい

;========================================================================================
;
    KX_set_mt32piVolume::                       ; mt32-pi の音量を設定します
;
;   arg     d0.w                                ; mt32-pi の指定音量
;                                               ;  (下位4bit $8:[0](-8) 〜 $7:[F](+7))
;   return  d0.b                                ; 実際に設定した音量
;                                               ;  ($F8:[0](-8) 〜 $07:[F](+7))
;
;----------------------------------------------------------------------------------------

    move.l  d1,-(sp)                            ; d1 を退避

    move.b  _KX_REG+_KX_SoundVolume1,d1         ; S/PDIF(光)入力、mt32-pi の音量を取得
    andi.b  #$F0,d1                             ; mt32-pi の音量 bit をクリアして
    andi.b  #$0F,d0                             ; 指定音量 4bit を適切に配置して
    or.b    d0,d1                               ;  差し込んで
    move.b  d1,_KX_REG+_KX_SoundVolume1         ;   書き込む
    lsl.b   #4,d0                               ; 設定した音量を一旦最上位bitへ移動させてから
    asr.b   #4,d0                               ;  signed byte 化

    move.l  (sp)+,d1                            ; d1 を復元
    rts                                         ; おしまい

;========================================================================================
;
    KX_turn_mt32piVolume::                      ; mt32pi の音量を相対設定します
;
;   arg     d0.b                                ; 指定相対音量 $80:-128 〜 $7F:+127
;   return  d0.b                                ; 実際に設定した音量
;                                               ;  ($F8:[0](-8) 〜 $07:[F](+7))
;
;----------------------------------------------------------------------------------------

    move.l  d1,-(sp)                            ; d1 を退避

    move.b  d0,d1                               ; 指定相対音量を d1 に
    bsr     KX_get_mt32piVolume                 ; 現在設定音量を d0 に
    bsr     KX_turn_Volume                      ; 設定する音量を取得
    bsr     KX_set_mt32piVolume                 ; 音量を設定

    move.l  (sp)+,d1                            ; d1 を復元
    rts                                         ; おしまい

;========================================================================================
;
    KX_get_YM2151Volume::                       ; YM2151 の音量を取得します
;
;   return  d0.b                                ; YM2151 の音量
;                                               ;  $F8:[0] 0% (-8) 〜 $07:[F] 187.5% (+7)
;
;----------------------------------------------------------------------------------------

    move.b  _KX_REG+_KX_SoundVolume1+1,d0       ; YM2151、ADPCM の音量を取得
    asr.b   #4,d0                               ; 音量を signed byte 化

    rts                                         ; おしまい

;========================================================================================
;
    KX_set_YM2151Volume::                       ; YM2151 の音量を設定します
;
;   arg     d0.w                                ; YM2151 の指定音量
;                                               ;  (下位4bit $8:[0](-8) 〜 $7:[F](+7))
;   return  d0.b                                ; 実際に設定した音量
;                                               ;  $F8:[0] 0% (-8) 〜 $07:[F] 187.5% (+7)
;
;----------------------------------------------------------------------------------------

    move.l  d1,-(sp)                            ; d1 を退避

    move.b  _KX_REG+_KX_SoundVolume1+1,d1       ; YM2151、ADPCM の音量を取得
    andi.b  #$0F,d1                             ; YM2151 の音量 bit をクリアして
    lsl.b   #$4,d0                              ; 指定音量 4bit を適切に配置して
    or.b    d0,d1                               ;  差し込んで
    move.b  d1,_KX_REG+_KX_SoundVolume1+1       ;   書き込む
    asr.b   #$4,d0                              ; 設定した音量を signed byte 化

    move.l  (sp)+,d1                            ; d1 を復元
    rts                                         ; おしまい

;========================================================================================
;
    KX_turn_YM2151Volume::                      ; YM2151 の音量を相対設定します
;
;   arg     d0.b                                ; 指定相対音量 $80:-128 〜 $7F:+127
;   return  d0.b                                ; 実際に設定した音量
;                                               ;  ($F8:[0](-8) 〜 $07:[F](+7))
;
;----------------------------------------------------------------------------------------

    move.l  d1,-(sp)                            ; d1 を退避

    move.b  d0,d1                               ; 指定相対音量を d1 に
    bsr     KX_get_YM2151Volume                 ; 現在設定音量を d0 に
    bsr     KX_turn_Volume                      ; 設定する音量を取得
    bsr     KX_set_YM2151Volume                 ; 音量を設定

    move.l  (sp)+,d1                            ; d1 を復元
    rts                                         ; おしまい

;========================================================================================
;
    KX_get_ADPCMVolume::                        ; ADPCM の音量を取得します
;
;   return  d0.b                                ; ADPCM の音量
;                                               ;  $F8:[0] 0% (-8) 〜 $07:[F] 187.5% (+7)
;
;----------------------------------------------------------------------------------------

    move.b  _KX_REG+_KX_SoundVolume1+1,d0       ; S/PDIF(光)入力、mt32-pi の音量を取得
    lsl.b   #4,d0                               ; 音量を一旦最上位bitへ移動させてから
    asr.b   #4,d0                               ;  signed byte 化

    rts                                         ; おしまい

;========================================================================================
;
    KX_set_ADPCMVolume::                        ; ADPCM の音量を設定します
;
;   arg     d0.w                                ; ADPCM の指定音量
;                                               ;  (下位4bit $8:[0](-8) 〜 $7:[F](+7))
;   return  d0.b                                ; 実際に設定した音量
;                                               ;  $F8:[0] 0% (-8) 〜 $07:[F] 187.5% (+7)
;
;----------------------------------------------------------------------------------------

    move.l  d1,-(sp)                            ; d1 を退避

    move.b  _KX_REG+_KX_SoundVolume1+1,d1       ; YM2151、ADPCM の音量を取得
    andi.b  #$F0,d1                             ; ADPCM の音量 bit をクリアして
    andi.b  #$0F,d0                             ; 指定音量 4bit を適切に配置して
    or.b    d0,d1                               ;  差し込んで
    move.b  d1,_KX_REG+_KX_SoundVolume1+1       ;   書き込む
    lsl.b   #4,d0                               ; 設定した音量を一旦最上位bitへ移動させてから
    asr.b   #4,d0                               ;  signed byte 化

    move.l  (sp)+,d1                            ; d1 を復元
    rts                                         ; おしまい

;========================================================================================
;
    KX_turn_ADPCMVolume::                       ; ADPCM の音量を相対設定します
;
;   arg     d0.b                                ; 指定相対音量 $80:-128 〜 $7F:+127
;   return  d0.b                                ; 実際に設定した音量
;                                               ;  ($F8:[0](-8) 〜 $07:[F](+7))
;
;----------------------------------------------------------------------------------------

    move.l  d1,-(sp)                            ; d1 を退避

    move.b  d0,d1                               ; 指定相対音量を d1 に
    bsr     KX_get_ADPCMVolume                  ; 現在設定音量を d0 に
    bsr     KX_turn_Volume                      ; 設定する音量を取得
    bsr     KX_set_ADPCMVolume                  ; 音量を設定

    move.l  (sp)+,d1                            ; d1 を復元
    rts                                         ; おしまい

;========================================================================================
;
    KX_get_SoundVolume2::                       ; Mercury Unit の音量を取得します
;
;   return d0.w                                 ; $ECB00A REG5: Sound Volume Adjust 2
;
;----------------------------------------------------------------------------------------

    move.w  _KX_REG+_KX_SoundVolume2,d0         ; Mercury Unit の音量を取得
    rts                                         ; おしまい

;========================================================================================
;
    KX_set_SoundVolume2::                       ; Mercury Unit の音量を設定します
;
;   arg     d0.w                                ; $ECB00A REG5: Sound Volume Adjust 2
;
;----------------------------------------------------------------------------------------

    move.w  d0,_KX_REG+_KX_SoundVolume2         ; Mercury Unit の音量を設定
    rts                                         ; おしまい

;========================================================================================
;
    KX_get_MercuryUnitFMVolume::                ; Mercury Unit FM の音量を取得します
;
;   return  d0.b                                ; Mercury Unit FM の音量
;                                               ;  $F8:[0] 0% (-8) 〜 $07:[F] 187.5% (+7)
;
;----------------------------------------------------------------------------------------

    move.b  _KX_REG+_KX_SoundVolume2,d0         ; Mercury Unit FM の音量を取得
    lsl.b   #4,d0                               ; 音量を一旦最上位bitへ移動させてから
    asr.b   #4,d0                               ;  signed byte 化

    rts                                         ; おしまい

;========================================================================================
;
    KX_set_MercuryUnitFMVolume::                ; Mercury Unit FM の音量を設定します
;
;   arg     d0.w                                ; Mercury Unit FM の指定音量
;                                               ;  (下位4bit $8:[0](-8) 〜 $7:[F](+7))
;   return  d0.b                                ; 実際に設定した音量
;                                               ;  ($F8:[0](-8) 〜 $07:[F](+7))
;
;----------------------------------------------------------------------------------------

    move.l  d1,-(sp)                            ; d1 を退避

    move.b  _KX_REG+_KX_SoundVolume2,d1         ; Mercury Unit FM の音量を取得
    andi.b  #$F0,d1                             ; Mercury Unit FM の音量 bit をクリアして
    andi.b  #$0F,d0                             ; 指定音量 4bit を適切に配置して
    or.b    d0,d1                               ;  差し込んで
    move.b  d1,_KX_REG+_KX_SoundVolume2         ;   書き込む
    lsl.b   #4,d0                               ; 設定した音量を一旦最上位bitへ移動させてから
    asr.b   #4,d0                               ;  signed byte 化

    move.l  (sp)+,d1                            ; d1 を復元
    rts                                         ; おしまい

;========================================================================================
;
    KX_turn_MercuryUnitFMVolume::               ; Mercury Unit FM の音量を相対設定します
;
;   arg     d0.b                                ; 指定相対音量 $80:-128 〜 $7F:+127
;   return  d0.b                                ; 実際に設定した音量
;                                               ;  ($F8:[0](-8) 〜 $07:[F](+7))
;
;----------------------------------------------------------------------------------------

    move.l  d1,-(sp)                            ; d1 を退避

    move.b  d0,d1                               ; 指定相対音量を d1 に
    bsr     KX_get_MercuryUnitFMVolume          ; 現在設定音量を d0 に
    bsr     KX_turn_Volume                      ; 設定する音量を取得
    bsr     KX_set_MercuryUnitFMVolume          ; 音量を設定

    move.l  (sp)+,d1                            ; d1 を復元
    rts                                         ; おしまい

;========================================================================================
;
    KX_get_MercuryUnitSSGVolume::               ; Mercury Unit SSG の音量を取得します
;
;   return  d0.b                                ; Mercury Unit SSG の音量
;                                               ;  $F8:[0] 0% (-8) 〜 $07:[F] 187.5% (+7)
;
;----------------------------------------------------------------------------------------

    move.b  _KX_REG+_KX_SoundVolume2+1,d0       ; Mercury Unit SSG、Mercury Unit PCM の音量を取得
    asr.b   #4,d0                               ; 音量を signed byte 化

    rts                                         ; おしまい

;========================================================================================
;
    KX_set_MercuryUnitSSGVolume::               ; Mercury Unit SSG の音量を設定します
;
;   arg     d0.w                                ; Mercury Unit SSG の指定音量
;                                               ;  (下位4bit $8:[0](-8) 〜 $7:[F](+7))
;   return  d0.b                                ; 実際に設定した音量
;                                               ;  ($F8:[0](-8) 〜 $07:[F](+7))
;
;----------------------------------------------------------------------------------------

    move.l  d1,-(sp)                            ; d1 を退避

    move.b  _KX_REG+_KX_SoundVolume2+1,d1       ; Mercury Unit SSG、Mercury Unit PCM の音量を取得
    andi.b  #$0F,d1                             ; Mercury Unit SSG の音量 bit をクリアして
    lsl.b   #$4,d0                              ; 指定音量 4bit を適切に配置して
    or.b    d0,d1                               ;  差し込んで
    move.b  d1,_KX_REG+_KX_SoundVolume2+1       ;   書き込む
    asr.b   #$4,d0                              ; 設定した音量を signed byte 化

    move.l  (sp)+,d1                            ; d1 を復元
    rts                                         ; おしまい

;========================================================================================
;
    KX_turn_MercuryUnitSSGVolume::              ; Mercury Unit SSG の音量を相対設定します
;
;   arg     d0.b                                ; 指定相対音量 $80:-128 〜 $7F:+127
;   return  d0.b                                ; 実際に設定した音量
;                                               ;  ($F8:[0](-8) 〜 $07:[F](+7))
;
;----------------------------------------------------------------------------------------

    move.l  d1,-(sp)                            ; d1 を退避

    move.b  d0,d1                               ; 指定相対音量を d1 に
    bsr     KX_get_MercuryUnitSSGVolume         ; 現在設定音量を d0 に
    bsr     KX_turn_Volume                      ; 設定する音量を取得
    bsr     KX_set_MercuryUnitSSGVolume         ; 音量を設定

    move.l  (sp)+,d1                            ; d1 を復元
    rts                                         ; おしまい

;========================================================================================
;
    KX_get_MercuryUnitPCMVolume::               ; Mercury Unit PCM の音量を取得します
;
;   return  d0.b                                ; Mercury Unit PCM の音量
;                                               ;  $F8:[0] 0% (-8) 〜 $07:[F] 187.5% (+7)
;
;----------------------------------------------------------------------------------------

    move.b  _KX_REG+_KX_SoundVolume2+1,d0       ; Mercury Unit SSG、Mercury Unit PCM の音量を取得
    lsl.b   #4,d0                               ; 音量を一旦最上位bitへ移動させてから
    asr.b   #4,d0                               ;  signed byte 化

    rts                                         ; おしまい

;========================================================================================
;
    KX_set_MercuryUnitPCMVolume::               ; Mercury Unit PCM の音量を設定します
;
;   arg     d0.w                                ; Mercury Unit PCM の指定音量
;                                               ;  (下位4bit $8:[0](-8) 〜 $7:[F](+7))
;   return  d0.b                                ; 実際に設定した音量
;                                               ;  ($F8:[0](-8) 〜 $07:[F](+7))
;
;----------------------------------------------------------------------------------------

    move.l  d1,-(sp)                            ; d1 を退避

    move.b  _KX_REG+_KX_SoundVolume2+1,d1       ; Mercury Unit SSG、Mercury Unit PCM  の音量を取得
    andi.b  #$F0,d1                             ; Mercury Unit PCM の音量 bit をクリアして
    andi.b  #$0F,d0                             ; 指定音量 4bit を適切に配置して
    or.b    d0,d1                               ;  差し込んで
    move.b  d1,_KX_REG+_KX_SoundVolume2+1       ;   書き込む
    lsl.b   #4,d0                               ; 設定した音量を一旦最上位bitへ移動させてから
    asr.b   #4,d0                               ;  signed byte 化

    move.l  (sp)+,d1                            ; d1 を復元
    rts                                         ; おしまい

;========================================================================================
;
    KX_turn_MercuryUnitPCMVolume::              ; Mercury Unit PCM の音量を相対設定します
;
;   arg     d0.b                                ; 指定相対音量 $80:-128 〜 $7F:+127
;   return  d0.b                                ; 実際に設定した音量
;                                               ;  ($F8:[0](-8) 〜 $07:[F](+7))
;
;----------------------------------------------------------------------------------------

    move.l  d1,-(sp)                            ; d1 を退避

    move.b  d0,d1                               ; 指定相対音量を d1 に
    bsr     KX_get_MercuryUnitPCMVolume         ; 現在設定音量を d0 に
    bsr     KX_turn_Volume                      ; 設定する音量を取得
    bsr     KX_set_MercuryUnitPCMVolume         ; 音量を設定

    move.l  (sp)+,d1                            ; d1 を復元
    rts                                         ; おしまい

;========================================================================================
;
    KX_get_SoundInputStatus::                   ; 外部音源入力の入力検出状態を取得します
;
;   return d0.w                                 ; $ECB0C REG6: Sound Input Status
;
;----------------------------------------------------------------------------------------

    move.w  _KX_REG+_KX_SoundInputStatus,d0     ; 外部音源入力の入力検出状態を取得
    rts                                         ; おしまい

;========================================================================================
;
    KX_get_mt32piOutInputStatus::               ; mt32-pi 出力からの入力検出状態を取得します
;
;   arg     d0.b                                ; mt32-pi 出力からの入力検出状態ID
;
;----------------------------------------------------------------------------------------

    move.b  _KX_REG+_KX_SoundInputStatus+1,d0   ; 外部音源入力の入力検出状態を取得
    andi.b  #$F0,d0                             ; mt32-pi 出力からの入力検出状態をマスクして
    lsr.b   #4,d0                               ;  数値化

    rts                                         ; おしまい

;========================================================================================
;
    KX_get_mt32piOutInputStatusName::           ; mt32-pi 出力からの入力検出状態名を取得します
;
;   return  a0.l                                ; mt32-pi 出力からの入力検出状態名
;
;----------------------------------------------------------------------------------------

    move.l  d0,-(sp)                            ; d0 を退避

    bsr     KX_get_mt32piOutInputStatus         ; 外部音源入力の入力検出状態を取得して
    bsr     KX_to_SoundInputStatusName          ;  入力検出状態名に変換

    move.l  (sp)+,d0                            ; d0 を復元
    rts                                         ; おしまい

;========================================================================================
;
    KX_get_SPDIFInInputStatus::                 ; S/PDIF(光)入力からの入力検出状態を取得します
;
;   arg     d0.b                                ; S/PDIF(光)入力からの入力検出状態ID
;
;----------------------------------------------------------------------------------------

    move.b  _KX_REG+_KX_SoundInputStatus+1,d0   ; 外部音源入力の入力検出状態を取得
    andi.b  #$0F,d0                             ; S/PDIF(光)入力からの入力検出状態をマスクして数値化

    rts                                         ; おしまい

;========================================================================================
;
    KX_get_SPDIFInInputStatusName::             ; S/PDIF(光)入力からの入力検出状態名を取得します
;
;   return  a0.l                                ; S/PDIF(光)入力からの入力検出状態名
;
;----------------------------------------------------------------------------------------

    move.l  d0,-(sp)                            ; d0 を退避

    bsr     KX_get_SPDIFInInputStatus           ; 外部音源入力の入力検出状態を取得して
    bsr     KX_to_SoundInputStatusName          ;  入力検出状態名に変換

    move.l  (sp)+,d0                            ; d0 を復元
    rts                                         ; おしまい

;========================================================================================
;
    KX_get_MIDIRouting::                        ; MIDI Routing のソースを取得します
;
;   return d0.w                                 ; $ECB010 REG8: MIDI Routing
;
;----------------------------------------------------------------------------------------

    move.w  _KX_REG+_KX_MIDIRouting,d0          ; MIDI Routing のソースを取得
    rts                                         ; おしまい

;========================================================================================
;
    KX_set_MIDIRouting::                        ; MIDI Routing のソースを設定します
;
;   arg     d0.w                                ; $ECB010 REG8: MIDI Routing
;
;----------------------------------------------------------------------------------------

    move.w  d0,_KX_REG+_KX_MIDIRouting          ; MIDI Routing のソースを設定
    rts                                         ; おしまい

;========================================================================================
;
    KX_get_mt32piInputSource::                  ; mt32-pi 入力のソースを取得します
;
;   return d0.b                                 ; mt32-pi 入力のソースID (下位 2bit)
;
;----------------------------------------------------------------------------------------

    move.b  _KX_REG+_KX_MIDIRouting+1,d0        ; MIDI Routing のソースを取得
    andi.b  #$0C,d0                             ; mt32-pi 入力のソースIDをマスクして
    lsr.b   #2,d0                               ;  数値化

    rts                                         ; おしまい

;========================================================================================
;
    KX_set_mt32piInputSource::                  ; mt32-pi 入力のソースを設定します
;
;   arg     d0.b                                ; mt32-pi 入力のソースID (下位 2bit)
;
;----------------------------------------------------------------------------------------

    move.l  d1,-(sp)                            ; d1 を退避

    move.b  _KX_REG+_KX_MIDIRouting+1,d1        ; MIDI Routing のソースを取得
    andi.b  #$F3,d1                             ; mt32-pi 入力のソースID部分に
    lsl.b   #2,d0                               ;  入力ソースIDを左へ2bit詰めて
    or.b    d0,d1                               ;   差し込んで
    move.b  d1,_KX_REG+_KX_MIDIRouting+1        ;    書き込む

    move.l (sp)+,d1                             ; d1 を復元
    rts                                         ; おしまい

;========================================================================================
;
    KX_get_mt32piInputSourceName::              ; mt32-pi 入力のソース名を取得します
;
;   return a0.l                                 ; mt32-pi 入力のソース名の先頭アドレス
;
;----------------------------------------------------------------------------------------

    move.l  d0,-(sp)                            ; d0 を退避

    bsr     KX_get_mt32piInputSource            ; mt32-pi 入力のソースIDを取得して
    bsr     KX_to_MIDIRoutingSourceName         ;  ソース名に変換

    move.l  (sp)+,d0                            ; d0 を復元
    rts                                         ; おしまい

;========================================================================================
;
    KX_get_MIDIExtOutSource::                   ; MIDI 外部出力のソースを取得します
;
;   return d0.b                                 ; MIDI 外部出力のソースID
;
;----------------------------------------------------------------------------------------

    move.b  _KX_REG+_KX_MIDIRouting+1,d0        ; MIDI Routing のソースを取得
    andi.b  #$03,d0                             ; MIDI 外部出力のソースIDをマスクして数値化

    rts                                         ; おしまい

;========================================================================================
;
    KX_set_MIDIExtOutSource::                   ; MIDI 外部出力のソースを設定します
;
;   arg     d0.b                                ; MIDI 外部出力のソースID
;
;----------------------------------------------------------------------------------------

    move.l  d1,-(sp)                            ; d1 を退避

    move.b  _KX_REG+_KX_MIDIRouting+1,d1        ; MIDI Routing のソースを取得
    andi.b  #$FC,d1                             ; MIDI 外部出力のソースID部分に
    or.b    d0,d1                               ;  入力ソースIDを差し込んで
    move.b  d1,_KX_REG+_KX_MIDIRouting+1        ;   書き込む

    move.l (sp)+,d1                             ; d1 を復元
    rts                                         ; おしまい

;========================================================================================
;
    KX_get_MIDIExtOutSourceName::               ; MIDI 外部出力ソース名を取得します
;
;   return a0.l                                 ; MIDI 外部出力ソース名の先頭アドレス
;
;----------------------------------------------------------------------------------------

    move.l  d0,-(sp)                            ; d0 を退避

    bsr     KX_get_MIDIExtOutSource             ; MIDI 外部出力ソースIDを取得して
    bsr     KX_to_MIDIRoutingSourceName         ;  ソース名に変換

    move.l  (sp)+,d0                            ; d0 を復元
    rts                                         ; おしまい

;========================================================================================
;
    KX_get_mt32piControl::                      ; mt32-pi のコントロールレジスタを取得します
;
;   return  d0.w                                ; $ECB012 REG9: mt32-pi control
;
;----------------------------------------------------------------------------------------

    move.w  _KX_REG+_KX_mt32piControl,d0        ; mt32-pi のコントロールレジスタを取得
    rts                                         ; おしまい

;========================================================================================
;
    KX_set_mt32piControl::                      ; mt32-pi のコントロールレジスタに書き込みます
;
;   arg  d0.w                                   ; $ECB012 REG9: mt32-pi control
;
;----------------------------------------------------------------------------------------

    move.l  d1,-(sp)                            ; d1 を退避

    move.w  #56*2-1,d1                          ; 約2秒分のループカウンタ
@@:
    bsr     KX_VSyncWait                        ; 垂直同期待ち
    btst.b  #7,_KX_REG+_KX_mt32piControl        ; busy フラグが
    dbeq    d1,@b                               ;  オフなら break (カウントダウンして0以上ならループ)
    bne     99f                                 ; 最後までカウントダウンされてたらずっと busy だったと
                                                ;  いうことなのでタイムアウトとみなしておしまい
    move.w  d0,_KX_REG+_KX_mt32piControl        ; mt32-pi のコントロールレジスタに書き込み
99:
    move.l  (sp)+,d1                            ; d1 を復元
    rts                                         ; おしまい

;========================================================================================
;
    KX_get_SystemClockFreq::                    ; X68K本体のシステムクロックの実測値を取得します
;
;   return d0.w                                 ; $ECB018 REG12: System Clock Freq (KHz)
;
;----------------------------------------------------------------------------------------

    move.w  _KX_REG+_KX_SystemClockFreq,d0      ; X68K本体のシステムクロックの実測値を取得
    rts                                         ; おしまい

;========================================================================================
;
    KX_get_HSyncFreq::                          ; 水平同期(H-Sync) 実測値(毎秒更新)を取得します
;
;   return d0.w                                 ; $ECB01A REG13: H Sync Freq (Hz)
;
;----------------------------------------------------------------------------------------

    move.w  _KX_REG+_KX_HSyncFreq,d0            ; 水平同期(H-Sync) 実測値
    rts                                         ; おしまい

;========================================================================================
;
    KX_get_VSyncFreq::                          ; 垂直同期(V-Sync) 実測値(10秒毎更新)を取得します
;
;   return d0.w                                 ; $ECB01C REG14: V Sync Freq (0.1Hz)
;
;----------------------------------------------------------------------------------------

    move.w  _KX_REG+_KX_VSyncFreq,d0            ; 垂直同期(V-Sync) 実測値
    rts                                         ; おしまい

;========================================================================================
;
    KX_get_AreaSetRegisterCache::               ; Human68k がエリアセットレジスタ $E86001 に書き込んだ値です
;
;   return d0.w                                 ; $ECB01E REG15: Area Set register cache (for $E86000)
;
;----------------------------------------------------------------------------------------

    move.w  _KX_REG+_KX_AreaSetRegisterCache,d0 ; Human68k がエリアセットレジスタに書き込んだ値
    rts                                         ; おしまい

;========================================================================================
;
    KX_get_Human68kSUPERVISORSize::             ; Human68k の SUPERVISOR エリアサイズを取得します
;
;   return d0.l                                 ; Human68k の SUPERVISOR エリアサイズ
;
;----------------------------------------------------------------------------------------

    move.w  _KX_REG+_KX_AreaSetRegisterCache,d0 ; Human68k がエリアセットレジスタに書き込んだ値
    andi.l  #$FF,d0                             ; 32bit化
    addq.l  #1,d0                               ; d0=(エリアセットレジスタ値+1)
    lsl.l   #8,d0                               ; d0=(エリアセットレジスタ値+1) * 256
    lsl.l   #5,d0                               ; d0=(エリアセットレジスタ値+1) * 8192

    rts                                         ; おしまい

;========================================================================================
;
    KX_VSyncWait::                              ; 垂直同期待ち
;
;----------------------------------------------------------------------------------------

@@:
    btst.b     #4,$00E88001                     ; V-DISP(MFP GPIP の bit4) が
    beq        @b                               ; 0 (垂直帰線期間) ならループ
@@: 
    btst.b     #4,$00E88001                     ; V-DISP(MFP GPIP の bit4) が
    bne        @b                               ; 1 (垂直表示期間) ならループ

    rts                                         ; おしまい

;========================================================================================


;========================================================================================
;
    KX_turn_Volume::                            ; 音量を相対的に上下する場合の設定音量を算出します
;
;   arg     d0.b                                ; 基準音量 $F8:[0](-8) 〜 $07:[F](+7)
;           d1.b                                ; 指定相対音量 $80:-128 〜 $7F:+127
;   return  d0.b                                ; 設定音量 $F8:[0](-8) 〜 $07:[F](-7)
;
;----------------------------------------------------------------------------------------

    cmp.b   #$0F,d1                             ; $0F:+15
    bge     1f                                  ;  以上($0F:+15 〜 $7F:+127 の範囲)ならば音量を $07:(+7) とするルートへ

    cmp.b   #$F1,d1                             ; $F1:-15
    ble     2f                                  ;  以下($80:-128 〜 $F1:-15 の範囲)ならば音量を $F8:(-8) とするルートへ

    add.b   d1,d0                               ; 退避していた d0 と加算

    cmp.b   #$07,d0                             ; $07:+7
    bgt     1f                                  ;  より大き($08:+8 〜 $7F:+127)ければ音量を $07:(+7) とするルートへ

    cmp.b   #$F8,d0                             ; $F8:-8
    blt     2f                                  ;  より小さ($F7:-9 〜 $80:-128)ければ音量を $F8:(-8) とするルートへ

    rts                                         ; おしまい
1:
    move.b  #$07,d0                             ; 指定音量を $07:(+7) とする
    rts                                         ; おしまい
2:
    move.b  #$F8,d0                             ; 指定音量を $F8:(-8) とする
    rts                                         ; おしまい

;========================================================================================
;
    KX_to_SoundInputStatusName::                ; 外部音源入力の入力検出状態IDから入力検出状態名に変換します
;
;   arg    d0.b                                 ; 外部音源入力の入力検出状態ID
;   return a0.l                                 ; 外部音源入力の状態名の先頭アドレス
;
;----------------------------------------------------------------------------------------

    tst.b  d0                                   ; $00 と比較して
    bne    @f                                   ; 違ったら次へ
    lea.l  KX_SoundInputStatusNone,a0           ; 状態名は 'None'
    bra    99f                                  ; おしまい
@@:
    cmp.b  #$01,d0                              ; $01 と比較して
    bne    @f                                   ; 違ったら次へ
    lea.l  KX_SoundInputStatus32,a0             ; 状態名は '32KHz'
    bra    99f                                  ; おしまい
@@:
    cmp.b  #$02,d0                              ; $02 と比較して
    bne    @f                                   ; 違ったら次へ
    lea.l  KX_SoundInputStatus44,a0             ; 状態名は '44.1KHz'
    bra    99f                                  ; おしまい
@@:
    cmp.b  #$03,d0                              ; $03 と比較して
    bne    @f                                   ; 違ったら次へ
    lea.l  KX_SoundInputStatus48,a0             ; 状態名は '48KHz'
    bra    99f                                  ; おしまい
@@:
    cmp.b  #$04,d0                              ; $04 と比較して
    bne    @f                                   ; 違ったら次へ
    lea.l  KX_SoundInputStatus96,a0             ; 状態名は '96KHz'
    bra    99f                                  ; おしまい
@@:
    lea.l  KX_SoundInputStatusReserved,a0       ; 状態名は 'Reserved'
99:
    rts                                         ; おしまい

;========================================================================================
;
    KX_to_MIDIRoutingSourceName::               ; MIDI Routing ソースIDからソース名に変換
;
;   arg     d0.b                                ; MIDI Routing ソースID
;   return  a0.l                                ; MIDI Routing ソース名の先頭アドレス
;
;----------------------------------------------------------------------------------------

    tst.b   d0                                  ; $00 と比較して
    bne     @f                                  ; 違ったら次へ
    lea.l   KX_MIDIRoutingSourceNone,a0         ; ソース名は 'None'
    bra     99f                                 ; おしまい
@@:
    cmp.b   #$01,d0                             ; $01 と比較して
    bne     @f                                  ; 違ったら次へ
    lea.l   KX_MIDIRoutingSourceMIDIIFOut,a0    ; ソース名は 'MIDI I/F Out'
    bra     99f                                 ; おしまい
@@:
    cmp.b   #$02,d0                             ; $02 と比較して
    bne     @f                                  ; 違ったら次へ
    lea.l   KX_MIDIRoutingSourceMIDIExtIn,a0    ; ソース名は 'MIDI External In'
    bra     99f                                 ; おしまい
@@:
    lea.l   KX_MIDIRoutingSourceReserved,a0     ; ソース名は 'Reserved'
99:
    rts                                         ; おしまい

;========================================================================================
.ifdef __DEBUG__
;========================================================================================
;
    KX_setup_sandbox::                          ; KeplerX ちゃんのテスト環境セットアップ
;
;----------------------------------------------------------------------------------------

    lea.l  _KX_REG,a6                           ; KeplerX ちゃんのレジスタの仮想アドレス

    cmp.w   #'KX',(a6)
    beq     99f
    move.l  #$4B5800FF,(a6)+ ; $ECB000
    move.l  #$0F010007,(a6)+ ; $ECB004
    move.l  #$0000000C,(a6)+ ; $ECB008
    move.l  #$00330000,(a6)+ ; $ECB00C
    move.l  #$00050000,(a6)+ ; $ECB010
    move.l  #$00000000,(a6)+ ; $ECB014
    move.l  #$27107B0C,(a6)+ ; $ECB018
    move.l  #$0226FF43,(a6)+ ; $ECB01C
99:
    rts                                         ; おしまい

;========================================================================================
.endif
;========================================================================================


;========================================================================================

    .data
    .even

;-------------------------------------------------------------------------------

KX_Name::
    .dc.b   'KeplerX',$00
KX_VersionCodeName:
    .dc.b   '零號機',$00,$00
    .dc.b   '壱號機',$00,$00
    .dc.b   '弐號機',$00,$00
    .dc.b   '参號機',$00,$00
    .dc.b   '肆號機',$00,$00
    .dc.b   '伍號機',$00,$00
    .dc.b   '陸號機',$00,$00
    .dc.b   '漆號機',$00,$00
    .dc.b   '捌號機',$00,$00
    .dc.b   '玖號機',$00,$00
    .dc.b   '拾號機',$00,$00
    .dc.b   '謎號機',$00,$00
KX_PatchVersionName:
    .dc.b   $F3,'P',$F3,'a',$F3,'t',$F3,'c',$F3,'h'
    .dc.b   $F3,'+',$F3,$00,$F3,$00
KX_NULL:
    .dc.b   $00
KX_SoundInputStatusNone:
    .dc.b   'None',$00
KX_SoundInputStatus32:
    .dc.b   '32KHz',$00
KX_SoundInputStatus44:
    .dc.b   '44.1KHz',$00
KX_SoundInputStatus48:
    .dc.b   '48KHz',$00
KX_SoundInputStatus96:
    .dc.b   '96KHz',$00
KX_SoundInputStatusReserved:
    .dc.b   'Reserved',$00
KX_MIDIRoutingSourceNone:
    .dc.b   'None',$00
KX_MIDIRoutingSourceMIDIIFOut:
    .dc.b   'MIDI I/F-Out',$00
KX_MIDIRoutingSourceMIDIExtIn:
    .dc.b   'MIDI Ext-In',$00
KX_MIDIRoutingSourceReserved:
    .dc.b   'Reserved',$00

;========================================================================================
